* Задачата за Ханойските кули да се реши със стек
* NFSA::printAllWords да се реши със стек
* NFSA::isFinite() да се реши и с DFS и с BFS

* Да се дефинира оператор NFSA::operator + такъв, че автоматът a + b да разпознава обединението на езиците на автоматите a и b

* Във варианта с намиране на път чрез рекурсия да се намери най-краткия път. Да се дефинира фунция 

[...] shortesWay (int x, int y, int tx, int ty)

чрез която може да се намери най-късият път между (x,y) и (tx,ty) с използван ена рекусия.

* Същото нещо за реализацията със стек

* Да се дефинирира метод int Tree::height(...)

* Де се дефинира метод int Tree::count(...), който преброява всички елементи на дървото

* Да се дефинира метод int Tree::countLeaves(...), който намира броя на листата на дървото

* Да се дефинира метод T Tree::sum (const T& null_val) на клас Tree, който намира и връща сумата на всички елементи на дървото (резултатът от приложението на оператора + над елементите. Нулевата стойност на типа се задава от параметъра null_val)

* Да се дефинира метод Tree::leaves(), който намира и връща вектор, съдържащ стойностите на всики листа на дървото

* Да се дефинира метод Tree::level (int k), който намира и връща вектор, съдържащ стойностите на всики елементи на дървово, които са на ниво k (т.е. има път от корена до тях с дължина k)

* Да се построи някое покриващо дърво на лабиринт

* Да се построи някое покриващо дърво на графа, съответен на краен автомат (т.е. за клас NFSA)

* Да се дефинира метод Tree::insertSorted (const T& x). Методът приема, че дървото е ДНД и вмъква елемента x в него така, че то да остане ДНД

* Да се дефинира метод Tree::isBOT (), който проверява дали дървото е ДНД. Методът да се реализира чрез рекурсия и чрез стек

* Да се дефинира метод bool Tree::memberBOT (const T& x), който проверява дали x е елемент на ДНД

* Да се дефинира метод bool Tree::memberGeneral (const T& x), който проверява дали x е елемент дървото (което може да не е ДНД)

* Да се дефинира функция bool symmetry (g1, g2), която проверява дали за вски път в g1 съществува огледален на него път в g2

* Да се дефинира функция [...] lengestProgression (g), която намира най-дългия път в g, състоящ се от нарастващи по стойност върхове






